package as.pw.candee.module.exploit;
import as.pw.candee.module.Module;
import as.pw.candee.setting.Setting;
import as.pw.candee.utils.Timer;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.math.MathHelper;
public class CornerClip extends Module {
        public final Setting<Boolean> autoDisable;
        private final Timer timer = new Timer(); public final Setting<Float> disableAfter;
        public CornerClip() {
                super("CornerClip", Categories.EXPLOIT, false, false);
                this.autoDisable = register(new Setting("AutoDisable", Boolean.FALSE));
                this.disableAfter = register(new Setting("DisableAfter", 1.0F, 5.0F, 0.1F, v -> this.autoDisable.getValue()));
        }
        public double roundToClosest(double num, double low, double high) {
                double d2 = high - num;
                double d1 = num - low;
                return (d2 > d1) ? low : high;
        }
        public boolean isMoving() {
                return (mc.gameSettings.keyBindForward.isKeyDown() || mc.gameSettings.keyBindBack
                        .isKeyDown() || mc.gameSettings.keyBindLeft
                        .isKeyDown() || mc.gameSettings.keyBindRight
                        .isKeyDown());
        }
        public void onEnable() {
                this.timer.reset();
        }
        public void onUpdate() {
                if (nullCheck() || isMoving())
                        return;
                if (this.autoDisable.getValue() && this.timer.passedMs((long)(this.disableAfter.getValue() * 1000.0F))) {
                        disable();
                        return;
                }
                if (mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().grow(0.01D, 0.0D, 0.01D)).size() < 2) {
                        mc.player.setPosition(
                                roundToClosest(mc.player.posX, Math.floor(mc.player.posX) + 0.301D, Math.floor(mc.player.posX) + 0.699D), mc.player.posY,
                                roundToClosest(mc.player.posZ, Math.floor(mc.player.posZ) + 0.301D, Math.floor(mc.player.posZ) + 0.699D));
                }
                else if (mc.player.ticksExisted % 5 == 0) {
                        mc.player.setPosition(mc.player.posX +
                                MathHelper.clamp(
                                        roundToClosest(mc.player.posX, Math.floor(mc.player.posX) + 0.241D, Math.floor(mc.player.posX) + 0.759D) - mc.player.posX, -0.03D, 0.03D), mc.player.posY, mc.player.posZ +
                                MathHelper.clamp(
                                        roundToClosest(mc.player.posZ, Math.floor(mc.player.posZ) + 0.241D, Math.floor(mc.player.posZ) + 0.759D) - mc.player.posZ, -0.03D, 0.03D));
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY, mc.player.posZ, true));
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(
                                roundToClosest(mc.player.posX, Math.floor(mc.player.posX) + 0.23D, Math.floor(mc.player.posX) + 0.77D), mc.player.posY,
                                roundToClosest(mc.player.posZ, Math.floor(mc.player.posZ) + 0.23D, Math.floor(mc.player.posZ) + 0.77D), true));
                }
        }
}