package as.pw.candee.module.exploit;
import java.awt.Color;

import as.pw.candee.CandeePlusRewrite;
import as.pw.candee.event.events.network.PacketEvent;
import as.pw.candee.event.events.world.BlockEvent;
import as.pw.candee.module.Module;
import as.pw.candee.setting.Setting;
import as.pw.candee.utils.InventoryUtil;
import as.pw.candee.utils.RenderUtil3D;
import as.pw.candee.utils.Timer;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Items;
import net.minecraft.item.ItemStack;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
public class InstantMine
        extends Module
{
    public InstantMine() {
                super("InstantMine", Categories.EXPLOIT, false, false);
                this.autoBreak = register(new Setting("AutoBreak", Boolean.TRUE));
                this.delay = register(new Setting("Delay", 20, 500, 0));
                this.picOnly = register(new Setting("Only Pickaxe", Boolean.TRUE));
                this.color = register(new Setting("Color", new Color(0, 0, 230, 90)));
                this.outline = register(new Setting("Outline", Boolean.FALSE));
                this.width = register(new Setting("Width", 2.0F, 5.0F, 0.2F, v -> this.outline.getValue()));
                this.silentSwitch = register(new Setting("SilentSwitch", Boolean.TRUE));
        }
        public void onRender3D() {
                if (FourZeroFourBlock != null) {
                        RenderUtil3D.drawBox(FourZeroFourBlock, 1.0D, this.color.getValue(), 63);
                        if (this.outline.getValue()) {
                                RenderUtil3D.drawBoundingBox(FourZeroFourBlock, 1.0D, this.width.getValue(), this.color.getValue());
                        }
                }
        }
        public void onUpdate() {
                if (!(CandeePlusRewrite.m_module.getModuleWithClass(SilentPickel.class)).isEnable) {
                        update();
                }
        }
        public void update() {
                if (nullCheck())
                        return;    if (FourZeroFourBlock != null && this.autoBreak.getValue() && breaktimer.passedMs(this.delay.getValue())) {
                        if (this.picOnly.getValue()) {
                                int bestPickSlot = getFastestPickaxeSlot();
                                if (bestPickSlot == -1)
                                        return;
                            int previousSlot = mc.player.inventory.currentItem;
                                if (this.silentSwitch.getValue()) {
                                        mc.player.connection.sendPacket(new CPacketHeldItemChange(bestPickSlot));
                                } else {
                                        InventoryUtil.switchToHotbarSlot(bestPickSlot, true);
                                }
                                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, FourZeroFourBlock, direction));
                                if (this.silentSwitch.getValue() && previousSlot != -1) {
                                        mc.player.connection.sendPacket(new CPacketHeldItemChange(previousSlot));
                                } else {
                                        InventoryUtil.switchToHotbarSlot(previousSlot, true);
                                }
                        } else {
                                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, FourZeroFourBlock, direction));
                        }
                        breaktimer.reset();
                }
        }
        private int getFastestPickaxeSlot() {
                int bestSlot = -1;
                float bestSpeed = 0.0F;
                for (int i = 0; i < 9; i++) {
                        ItemStack stack = mc.player.inventory.getStackInSlot(i);
                        if (stack.getItem() == Items.DIAMOND_PICKAXE) {
                                float speed = stack.getDestroySpeed(mc.world.getBlockState(FourZeroFourBlock));
                                if (speed > bestSpeed) {
                                        bestSpeed = speed;
                                        bestSlot = i;
                                }
                        }
                }
                return bestSlot;
        }
        public void onPacketSend(PacketEvent.Send event) {
                if (nullCheck()) {
                        return;
                }
                Packet<?> packet = event.getPacket();
                if (packet instanceof CPacketPlayerDigging && ((CPacketPlayerDigging)packet).getAction() == CPacketPlayerDigging.Action.START_DESTROY_BLOCK && packetCancel) {
                        event.cancel();
                }
        }
        @SubscribeEvent
        public void OnDamageBlock(BlockEvent event) {
                if (nullCheck()) {
                        return;
                }
                if (!this.isEnable) {
                        return;
                }
                startBreak(event.pos, event.facing);
                event.cancel();
        }
        public static void startBreak(BlockPos pos, EnumFacing facing) {
                if (!canBreak(pos)) {
                        resetMining();
                        return;
                }
                if (!pos.equals(lastBlock)) {
                        resetMining();
                        packetCancel = false;
                        mc.player.swingArm(EnumHand.MAIN_HAND);
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
                }
                packetCancel = true;
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, facing));
                FourZeroFourBlock = pos;
                lastBlock = pos;
                direction = facing;
        }
        private static boolean canBreak(BlockPos pos) {
                IBlockState blockState = mc.world.getBlockState(pos);
                Block block = blockState.getBlock();
                return (block.getBlockHardness(blockState, mc.world, pos) != -1.0F);
        }
        public static void cancelMining() {
                if (FourZeroFourBlock != null && direction != null) {
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, FourZeroFourBlock, direction));
                        resetMining();
                }
        }
        public static void resetMining() {
                FourZeroFourBlock = null;
                lastBlock = null;
                direction = null;
                packetCancel = false;
        }
        private static boolean packetCancel = false;
        private static final Timer breaktimer = new Timer();
        private static final Timer timer = new Timer();
        public final Setting<Boolean> autoBreak;
        public final Setting<Integer> delay;
        public final Setting<Boolean> picOnly;
        public final Setting<Color> color;
        public final Setting<Boolean> outline;
        public final Setting<Float> width;
        public final Setting<Boolean> silentSwitch;
        private static EnumFacing direction;
        public static BlockPos FourZeroFourBlock;
        private static BlockPos lastBlock;
}